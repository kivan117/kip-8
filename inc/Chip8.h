#pragma once
#include "stdint.h"
#include "Registers.h"
#include "Logger.h"
#include <iostream>
#include <string>
#include <chrono>
#include <vector>

class Chip8
{
public:
	enum SYSTEM_MODE { CHIP_8, SUPER_CHIP, XO_CHIP };
private:
	uint8_t Memory[0x10000] = { 0 };
	uint8_t Font[80] = {
		0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
		0x20, 0x60, 0x20, 0x20, 0x70, // 1
		0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
		0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
		0x90, 0x90, 0xF0, 0x10, 0x10, // 4
		0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
		0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
		0xF0, 0x10, 0x20, 0x40, 0x40, // 7
		0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
		0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
		0xF0, 0x90, 0xF0, 0x90, 0x90, // A
		0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
		0xF0, 0x80, 0x80, 0x80, 0xF0, // C
		0xE0, 0x90, 0x90, 0x90, 0xE0, // D
		0xF0, 0x80, 0xF0, 0x80, 0xF0, // E
		0xF0, 0x80, 0xF0, 0x80, 0x80, // F
	};
	uint8_t LargeFont[160] = {
		0xFF, 0xFF, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, // 0
		0x18, 0x78, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0xFF, // 1
		0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, // 2
		0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 3
		0xC3, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, 0x03, 0x03, 0x03, 0x03, // 4
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 5
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, // 6
		0xFF, 0xFF, 0x03, 0x03, 0x06, 0x0C, 0x18, 0x18, 0x18, 0x18, // 7
		0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, // 8
		0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 9
		0x7E, 0xFF, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, 0xC3, 0xC3, 0xC3, // A
		0xFC, 0xFC, 0xC3, 0xC3, 0xFC, 0xFC, 0xC3, 0xC3, 0xFC, 0xFC, // B
		0x3C, 0xFF, 0xC3, 0xC0, 0xC0, 0xC0, 0xC0, 0xC3, 0xFF, 0x3C, // C
		0xFC, 0xFE, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xFE, 0xFC, // D
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, // E
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0  // F
	};

	uint8_t LogoRom[97] = {
		0x00, 0xE0, // cls
		0x60, 0x0B, // ld v0 0x0B
		0x61, 0x08, // ld v1 0x08
		0x62, 0x0F, // ld v2 0x0F
		0xA2, 0x16, // set i = 0x216 (start of logo data)
		0xD0, 0x1F, // draw v0 v1 15, draw 15 line tall letter at v0,v1
		0xF2, 0x1E, // i += v2, move to next character in logo
		0x70, 0x08, // v0 += 0x08 (move draw location right 8 pixels)
		0x30, 0x33, // skip next instruction if v0 == 51, we're done drawing all letters so stop looping
		0x12, 0x0A, // jump 20A (draw command)
		0x12, 0x14, // jump 214 (infinite loop)
		0xC3, 0xC7, 0xCE, 0xDC, 0xF8, 0xF0, 0xE0, 0xE0, 0xE0, 0xF0, 0xF8, 0xDC, 0xCE, 0xC7, 0xC3, // K
		0x7E, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x7E, // I
		0xFF, 0xFF, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, // P
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // -
		0x7E, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0x7E, 0x3C, 0x7E, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0x7E  // 8
	};

	uint8_t RPLMemory[8] = { 0 };
	bool write_rpl = false;

	uint8_t FrameBuffer[64 * 128] = { 0 };
	uint8_t PreviousFramebuffer[128 * 64] = { 0 };
	uint8_t active_plane = 1; //Bit mask for XO-chip+ graphics planes. LSB is plane 1. Planes are stacked over each other, with plane 1 on bottom.

	

	uint8_t Keys[16] = { 0 }; //keypad keys
	uint8_t PrevKeys[16] = { 0 };

	Registers regs;

	int8_t sp = -1;

	uint16_t Stack[64];
	uint8_t StackSize = 12;

	uint16_t EntryPoint = 0x200;
	uint16_t RamLimit = 0xFFF;

	uint16_t pc = 0x200;

	uint8_t sound_timer = 0;
	uint8_t delay_timer = 0;

	bool screen_dirty = false;
	bool wipe_screen = true;
	SYSTEM_MODE mode = CHIP_8;

	bool debug_stepping = false;
	bool halted = false;

	uint16_t m_Run_Cycles = 0;

	uint16_t Fetch(uint16_t location);
	void Decode_Execute(uint16_t opcode);

public:
	Chip8();
	~Chip8();
	void Reset();
	void ResetMemory(bool randomize);
	void Load(const std::vector<unsigned char> &buffer);
	void Run(uint16_t cycles);
	uint8_t* GetVRAM();
	uint8_t* GetPrevVRAM();
	void SaveCurrentVRAM();
	uint8_t GetSoundTimer() { return sound_timer; }
	uint8_t GetDelayTimer() { return delay_timer; }
	void SetSoundTimer(uint8_t val) { sound_timer = val; return; }
	void SetDelayTimer(uint8_t val) { delay_timer = val; return; }
	bool GetScreenDirty() { return screen_dirty; }
	void SetScreenDirty();
	void ResetScreenDirty() { screen_dirty = false; return; }
	bool GetWipeScreen() { return wipe_screen; }
	void SetWipeScreen() { wipe_screen = true; }
	void ResetWipeScreen() { wipe_screen = false; }
	void SetHiRes() { res.hires = true; return; }
	void SetLowRes() { res.hires = false; return; }
	void SetKey(uint8_t key, uint8_t val) { PrevKeys[key] = Keys[key]; Keys[key] = val; return; }
	uint8_t* GetRegV(uint8_t index) { return &regs.v[index % 0x10]; }
	uint16_t* GetRegI() { return &regs.i; }
	uint16_t* GetPC() { return &pc; }
	int8_t* GetSP() { return &sp; }
	uint8_t GetStackSize() { return StackSize; }
	uint16_t* GetStack() { return &Stack[0]; }
	bool GetDebugStepping() { return debug_stepping; }
	void Step() { m_Run_Cycles += 1; }
	bool GetHalted() { return halted; }
	void Halt() { halted = true; m_Run_Cycles = 0; return; }
	void UnHalt() { halted = false; }
	bool ToggleDebugStepping();
	void SetSystemMode(SYSTEM_MODE newmode);
	SYSTEM_MODE GetSystemMode();
	uint8_t* GetRAM() { return &Memory[0]; }
	uint16_t GetRAMLimit() { return RamLimit; }
	uint8_t* GetRPLMem() { return &RPLMemory[0]; }
	void SetRPLMem(uint8_t* input) { memcpy(RPLMemory, input, 8); }
	bool RequestsRPLSave() { return write_rpl; }
	void ResetRPLRequest() { write_rpl = false; }

	struct Quirks {
		bool vip_jump = false;                //always jump to NNN + V0
		bool vip_shifts = false;             //copy VY into VX before shifting VX register
		bool vip_regs_read_write = false;    //increment I register when reading/writing regs to/from RAM
		bool logic_flag_reset = false;                  //reset flag register to 0 when doing logic OR, AND, XOR ops
		bool draw_wrap = false;              //items drawn off screen wrap to the other side
		bool draw_vblank = false;
		bool schip_10_fonts = false;
		bool schip_10_regs_read_write = false; //i is incremented 1 less than it should be, super-chip 1.0 only behavior
	} quirks;

	struct Resolution {
		uint8_t base_width = 64;
		uint8_t base_height = 32;
		bool hires = false;
	} res;

	uint8_t audio_pattern[16] = { 0xF0 };
};

